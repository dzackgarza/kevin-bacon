package New;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Map.Entry;
import New.BFSTree.Node;

public class Graph {
	// Set the two actors to search for here.
	String actorA = "Kevin Bacon";
	String actorB = "William Shatner";
	
	// CSV with actors and movies to be read in.
	static String fileIn;
	
	private HashMap<String, Vertex> actorMap; 					// Name => Vertex
	private HashMap<String, HashSet<String>> movieCastLists;	// Movie => Cast List
	
	// Holds all nodes generated by bidirectional BFS.
	BFSTree<Vertex> tA;
	BFSTree<Vertex> tB;
	
	// Holds the final tree with a path from B to A.
	BFSTree<Vertex> sourceTree;
		
	/** Graph Constructor **/
	public Graph() {
		fileIn = "actorfile.csv";
		actorMap = new HashMap<String, Vertex>();
		movieCastLists = new HashMap<String, HashSet<String>>();
	}
	
	/** Graph Members **/
	class Vertex {
		String actorName;
		int baconNumber;
		Edge reversePath;
		LinkedList<Edge> neighbors;
		HashSet<String> movieTitles;
		
		Vertex (String name) {
			actorName = name;
			baconNumber = Integer.MAX_VALUE;
			neighbors = new LinkedList<Edge>();
			movieTitles = new HashSet<String>();
		}
		
		boolean equals(Vertex B){
			if (this.actorName.equalsIgnoreCase(B.actorName)) return true;
			else return false;
		}
	}
	
	class Edge {
		Vertex endpoint;
		String movieName;
		
		public Edge(Vertex neighbor, String movieName) {
			this.endpoint = neighbor;
			this.movieName = movieName;
		}
		
	}
	
	
	/** Helper Functions **/
	void addVertex(String actorName, String movieName) 
	{
		Vertex v = (Vertex) getVertex(actorName);
		v.movieTitles.add(movieName);
		
		HashSet<String> castList = (HashSet<String>) movieCastLists.get(movieName);
		if (castList == null) {
			castList = new HashSet<String>();
		}
		castList.add(actorName);
		movieCastLists.put(movieName, castList);
	}
	
	// Pass in an actor's name to get a vertex. Creates one if it doesn't exist.
	Vertex getVertex (String actorName) {
		Vertex v = (Vertex) actorMap.get(actorName);
		if (v == null) {
			v = new Vertex(actorName);
			actorMap.put(actorName, v);
		}
		return v;
	}
	
	// Add an edge to a source vertex. Edges signify two vertices were coActors in a movie.
	void addEdge(String source, String destination, String movieName) 
	{
		Vertex s = getVertex(source);
		Vertex d = getVertex(destination);
		s.neighbors.add(new Edge(d, movieName));
	}
	
	// Primary outside interface to the graph. Call this to generate everything.
	void buildGraph() {
		buildVerticesFromFile();
		buildEdges();
	}
	
	void buildVerticesFromFile()
	{
		BufferedReader in = null;
		String line;
		long begin = System.currentTimeMillis();
		
		System.out.println("Reading in file...");
		
		try {
			in = new BufferedReader(new FileReader(fileIn));
			while ((line = in.readLine()) != null)
			{
				String[] d = line.split(",");
				String actor = d[1];
				String film = d[3];
				addVertex(actor, film);
			}
		} catch(FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if (in != null) {
				try {
					in.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}	
		}
		System.out.println("File read. (" + (System.currentTimeMillis() - begin)/1000.0 +" s)");
	}
	
	public void buildEdges () 
	{
		long begin = System.currentTimeMillis();
		System.out.println("Building edges...");
		
		for (Entry<String, HashSet<String>> s : movieCastLists.entrySet()) {
			String movie = s.getKey();
			HashSet<String> actors = s.getValue();
			for (String A : actors) {
				for (String B : actors) {
					 if ( !A.equals(B) ) 
						 addEdge(A, B, movie);
				}
			}
		}
		System.out.println("Completed. (" 
		+ (System.currentTimeMillis() - begin)/1000.0 + " s)");
	} 
	
	void shortestPath(String actorA, String actorB) 
	{
		Vertex A = (Vertex) getVertex(actorA);
		Vertex B = (Vertex) getVertex(actorB);
		BFS1(A,B);
		printPath(A,B);
	}
	
	/** Primary search algorithm. Performs a bidirectional breadth-first search.
	 *  Given two actors, we switch back and forth between searching through
	 *  all of a given actor's coActors and keep track of which actors were
	 *  found, then add them to a tree. As soon as there is an actor common to both
	 *  A and B's trees of coActors, we know there is a path between A and B. 
	 *  
	 *  We then start from the shorter of the two trees, say T1, add the common actor
	 *  from T2, and trace T2 back to its root -- which is actor B. This gives 
	 *  a path between A and B, and the search scales as 2n^(d/2) instead of n^d,
	 *  where n is the total number of actors to search and d is the level of
	 *  a single tree generated by simply performing a BFS with one actor.
	 */
	void BFS1(Vertex A, Vertex B) 
	{
		System.out.println("Performing BFS...");
		
		long begin = System.currentTimeMillis();
		A.baconNumber = 0;
		HashSet<String> visited = new HashSet<String>()
				;
		Queue<Vertex> qA = new LinkedList<Vertex>();
		Queue<Vertex> qB = new LinkedList<Vertex>();
		
		//	Build two trees, with A and B as the respective roots.
		tA = new BFSTree<Vertex>(A);
		tB = new BFSTree<Vertex>(B);
		
		// Maintain two separate queues to minimize depth of traversal.
		qA.add(A);
		qB.add(B);
		
		boolean searchA = false;
		
		while (!qA.isEmpty() && !qB.isEmpty()) {
			searchA = !searchA; 
			// 	Switch off between searching from A and from B.
			
			if (searchA) {
				// Pop actor from the queue to examine it.
				Vertex currentA = qA.remove();
				// Keep track of which actors we've seen.
				visited.add(currentA.actorName);
				
				// As soon as there is an actor common to A and B, 
				// a path exists between them.
				if (currentA.equals(B) | visited.contains(currentA.actorName)) {
					buildPath(tA, tB, currentA);
					return;
				}
				
				else {
					// Iterate through coActors
					for (Edge e : currentA.neighbors) {
						Vertex n = e.endpoint;
						// Queue all coActors that haven't been seen yet.
						if (!visited.contains(n.actorName)) {
							n.baconNumber = currentA.baconNumber + 1;
							// Add to the queue so it can be processed.
							qA.add(n);
							// Add to the tree to generate return path.
							tA.addNode(n, currentA, e.movieName);
						}
					}
				}
			} // End search A
			
			else { // Do essentially the same thing with actor B.
				Vertex currentB = qB.remove();
				visited.add(currentB.actorName);
				
				if (currentB.equals(A) | visited.contains(currentB.actorName)) {
					buildPath(tB, tA, currentB);
					return;
				}
				
				else {
					for (Edge e : currentB.neighbors) {
						Vertex n = e.endpoint;
						if (!visited.contains(n.actorName)) {
							n.baconNumber = currentB.baconNumber + 1;
							qA.add(n);
							tB.addNode(n, currentB, e.movieName);
						}
					}
				}
			} // End search B
			
		}
		
		System.out.println("Completed. (" + 
				(System.currentTimeMillis() - begin)/1000.0 + " s)");
	}
	
	// 	Build a path from commonActor in tree A to the destination actor (i.e., the 
	//	root of the other tree B) by adding nodes in B to A, reversing the parent-
	// 	child relationship to trace B back to the root. A path is then built by 
	//  following all parents links from B to its root (now in Tree A).
	void buildPath (BFSTree<Vertex> sourceA, BFSTree<Vertex> sourceB, Vertex commonActor) {
		Node<Vertex> currentA = sourceA.getNode(commonActor);
		Node<Vertex> currentB = sourceB.getNode(commonActor);
		
		while (currentB.parent != null) {
			currentA.children.add(currentB);
			Node<Vertex> newDestination = currentB.parent;
			currentB.parent = currentA;
			currentA = currentB;
			currentB = newDestination;
		}
	}
	
	void printPath (Vertex A, Vertex B) 
	{
		BFSTree<Vertex> source = this.sourceTree;
		Node<Vertex> start = source.getNode(A);
		Node<Vertex> destination = source.getNode(B);
		while (start != destination) {
			
			String actorName = destination.data.actorName;
			String movieName = destination.movieWithParent;
			String coActor = destination.parent.data.actorName;
			
			System.out.println(actorName + " was in " 
					+ movieName  + " with "
					+ coActor + ".");
			destination = destination.parent;
		}
		System.out.println("----------------------------------------");
		System.out.println(B.actorName + "'s Bacon Number is " + B.baconNumber);
	}
	
	public static void main(String[] args) 
	{
		Graph g = new Graph();
		
		
		g.buildGraph();
		g.runTests();
		//g.shortestPath(actorA, actorB);
		
	}
	void runTests()
	{
		//testMovieList(); 	// Replaced by Cast List Hashes //
		//testMovieHash();
		testGetActorsFromMovieHash();
	}
	
	// 16,698 Movies --> addVertex() functions properly.
	/* void testMovieList()
	{
		System.out.println("Printing movies...");
		System.out.println("------------------");
		int count = 0;
		for (String s: allMovies) {
			System.out.println(s);
			count++;
		}
		System.out.println("------------------");
		System.out.println(count + " Movies added successfully.");

	}*/
	
	// 16,698 Movies --> addVertex() functions properly.
	void testMovieHash() 
	{
		System.out.println("Printing movies from Cast List Hash...");
		System.out.println("------------------");
		int count = 0;
		for (String s: movieCastLists.keySet()) {
			System.out.println(s);
			count++;
		}
		System.out.println("------------------");
		System.out.println(count + " Movies successfully Hashed.");
	}
	
	void testGetActorsFromMovieHash()
	{
		int movieCount = 0;
		for (Entry<String, HashSet<String>> s : movieCastLists.entrySet()) 
		{
			movieCount++;
			int actorCount = 0;
			String movie = s.getKey();
			HashSet<String> actors = s.getValue();
			System.out.println("Movie: " + movie);
			for (String A : actors) {
				actorCount++;
				System.out.println(A);
				
			}
			System.out.println("Total Actors: " + actorCount);
			System.out.println("----------------------");
		}
		System.out.println("Total Movies: " + movieCount);
	}
}
